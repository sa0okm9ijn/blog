---
title: 汉诺塔
date: 2019-05-29 14:09:54
tags: 
- 算法
categories: 算法
description: 
---
汉诺塔问题是一个经典的问题。汉诺塔（Hanoi
Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？



![](584421-20180725154536395-382941920.png)

**分析**

初次看到这个问题可能无从下手，A--->B还是A--->C 很难选择。甚至第二步、第三步。。。。。可能都无法选择。可能胡乱移动下去，最后可能发现已经动不了

**问题分解**

考虑如何一步一步的移动可能会非常吃力。我们可以每一次的移动看成一个整体的移动，如上图所示。我们可以假设

A柱63原盘移动到了B柱，然后A柱移动到C柱

B柱62原盘移动到了A柱，然后B柱移动到C柱

A柱61原盘移动到了B柱，然后A柱移动到C柱



可以概括为每次都是先将原盘移动到辅助柱子上，并将最底下的原盘移动到C柱上，然后再把原先柱作为辅助柱，并重复此过程

这个过程即为递归，即定义一组基本操作，这组操作将规模小一点（或大一点）的操作当做一个整体----无需关心它的细节，只当它已经完成了----
然后执行剩下的操作。而在更小或更大的规模中也依此操作，直到规模达到预定值。

如此 我们可以用代码实现



    
```
def move(n,a,b,c):
    if n==1:
        print('move',a,'--->',c)
    else:
        #移动原盘从a到辅助盘上
        move(n-1,a,c,b)
        #移动原盘从a到c
        move(1,a,b,c)
        #移动原盘从b到c
        move(n-1,b,a,c)
move(4,'A','B','C')
``` 


