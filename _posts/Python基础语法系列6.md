---
title: Python基础语法系列6
date: 2019-07-16 08:26:05
tags: 
- python  
categories: python  
description: 
---

## 编码

在开始我们今天的话题前，我们先引入几个问题。在你的网络冲浪生涯里，我想你或多或少有这样的疑问：
1、为什么传说中只能读懂0和1的计算机能显示如此五花八门的内容？
2、为什么明明办的100兆的宽带，撑死就只有10几兆的下载速度？
3、为什么有时打开文件会出现这样像中毒一般的“火星文”？

编码的本质就是让只认识0和1的计算机，能够理解我们人类使用的语言符号，并且将数据转换为二进制进行存储和传输。
这种从人类语言到计算机语言转换的形式，就叫做编码表，它让人类语言和计算机语言能够一一对应起来。
要了解编码，我们还得先来聊聊二进制。由于有二进制，0和1这两个数字才能像“太极生两仪，两仪生四象，四象生八卦”一样，涵盖容纳世间所有的信息。

### 二进制
说起二进制，我就想起了周幽王烽火戏诸侯。西周时周幽王，为褒姒（bāo sì）一笑，点燃了烽火台，戏弄了诸侯。褒姒看了果然哈哈大笑。幽王很高兴，因而又多次点燃烽火。后来诸侯们都不相信了，也就渐渐不来了。后来犬戎攻破镐京，杀死周幽王。接下来我们以点燃烽火为例，来说明计算机怎么传输和存储数据的

假设我们都是看守城墙的小兵，你在烽火台A上，我在烽火台B上，只要你那边来了敌人，你就点着烽火台通知我。

如果只有一个烽火台，那么只有“点着火”和“没点火”两种状态，这就像电子元件里“通电”和“没通电”的状态，所以只有0和1.

但是你光告诉我来敌人还不够啊，还得告诉我敌人的数量有多少，让我好call齐兄弟做好准备。现在问题是你要怎么通知我敌人的数量呢？

所以，我们之间就约定了特别的“暗号”，来通知彼此敌情。

![2019-07-12_112104](2019-07-12_112104.png)

现在有两座烽火台，右边为第1座，左边为第2座。我们约定，当没有烽火台被点着的时候，表示没有敌人（00）；只点着第一座烽火台的时候，表示来了一个敌人(01)；只点着第二座烽火台的时候，表示来了2个敌人。(10,逢二进一)

当两座烽火台都被点着的时候（11），就表示来了3个人。

也就是这样的对应关系：

| 二进制  | 十进制  |
| ---|---|
| 00  | 0  |
| 01  | 1  |
| 10  | 2  |
| 11  | 3  |

所以两个二进制位可以表示十进制的0,1,2,3四种状态。

现在你应该可以听得懂这个笑话：世界上有10种人，懂二进制和不懂二进制的。

我们继续往下推，当有三座烽火台的时候，我们可以表示0~7八种状态（也就是2的3次方）。

![L-15-27-2019124154824](L-15-27-2019124154824.png)

以此类推，当有八座烽火台的时候，我们就能表示2的8次方，也就是256种状态，它由8个0或1组成。

```
00000000 表示状态0: 烽火全暗，一个敌人没有，平安无事，放心睡觉。
11111111 表示状态255：烽火全亮，来了255个敌人。起来打啊！
```
用来存放一位0或1，就是计算机里最小的存储单位，叫做【位】，也叫【比特】（bit）。我们规定8个比特构成一个【字节】（byte），这是计算机里最常用的单位。

bit和byte长得有点像，可别混淆！1 byte = 8 bit，也就是1字节等于8比特。

到了这里上面的关于百兆流量的问题我们也就知道了，是因为运营商的带宽是以比特每秒为单位的，比如100M就是100Mbit/s，而我们常看到的下载速度KB却是以字节每秒为单位显示的，1byte = 8bit，所以运营商说的带宽得先除以8，你的百兆宽带下载速度，也就是十几兆了。


### 编码表
计算机一开始发明的时候，只是用来解决数字计算的问题。后来人们发现，计算机还可以做更多的事，正所谓能力越大，责任越大。但由于计算机只识“数”，因此人们必须告诉计算机哪个数字来代表哪个特定字符。

于是除了0、1这些阿拉伯数字，像a、b、c这样的52个字母（包括大小写），还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，理论上每个人都可以有自己的一套规则（这就叫编码）。

但大家如果想要互相沟通而不造成混乱，就必须使用相同的编码规则。如果使用了不同的编码规则，那就会彼此读不懂，这就是“乱码”的由来。这也就可以解释上面打开文本文件出现"火星文"的原因了,存储和读取编码规则不同。出现了了乱码

为了避免乱码，一段世界历史就此启动。一开始，是美国首先出台了ASCII编码（读音：/ˈæski/），统一规定了常用符号用哪些二进制数来表示。

因为英文字母、数字再加上其他常用符号，也就100来个，因此使用7个比特位（最多表示128位）就够用了，所以一个字节中被剩下的那个比特位就被默认为0。

再后来呢，这套编码表传入欧洲，才发现这128位不够用啊。比如说法语字母上面还有注音符，这个怎么区分？得！把最后一个比特位也编进来吧。因此欧洲普遍使用一个全字节（8个比特位）进行编码，最多可表示256位，至此，一个字节就用满了！

但是前面的状态0-127位可以共用，但从状态128到255这一段的解释就完全乱套了，比如135在法语，希伯来语，俄语编码中完全是不同的符号。

当计算机漂洋过海来到中国后，问题又来了，计算机完全不认识博大精深的中文，当然也没法显示中文；而且一个字节的256位都被占满了，但中国有10万多个汉字，256位连塞牙缝都不够啊。

于是中国科学家自力更生，重写了一张编码表，也就是GB2312，它用2个字节，也就是16个比特位，来表示绝大部分（65535个）常用汉字。后来，为了能显示更多的中文，又出台了GBK标准。

不仅中国，其他国家也都搞出自己的一套编码标准，这样的话地球村村民咋沟通？日本人发封email给中国人，两边编码表不同，显示的都是乱码。

为了沟通的便利，Unicode（万国码）应运而生，这套编码表将世界上所有的符号都纳入其中。每个符号都有一个独一无二的编码，现在Unicode可以容纳100多万个符号，所有语言都可以互通，一个网页上也可以显示多国语言。

看起来皆大欢喜。但是！问题又来了，自从英文世界吃上了Unicode这口大锅饭，为迁就一些占用字节比较多的语言，英文也要跟着占两个字节。比如要存储A，原本00010001就可以了，现在偏得用两个字节：00000000 00010001才行，这样对计算机空间存储是种极大的浪费！

基于这个痛点，科学家们又提出了天才的想法：UTF-8（8-bit Unicode Transformation Format）。它是一种针对Unicode的可变长度字符编码，它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，而当字符在ASCII码的范围时，就用一个字节表示，所以UTF-8还可以兼容ASCII编码。

Unicode与UTF-8这种暧昧的关系一言以蔽之：Unicode是内存编码的规范，而UTF-8是如何保存和传输Unicode的手段。

unicode编码表:https://unicode-table.com/cn/




## 文件读取
```
file1 = open('绝对或相对路径','a',encoding='utf-8')
file1.read()
file1.close()

```

## 文件写入

```
file1 = open('绝对或相对路径','a',encoding='utf-8')
file1.write('写入的内容')
file1.close()
```

## 关于读写模式参数选择
![L-15-25-201911515955](L-15-25-201911515955.png)

## 使用with关键字读写文件

```
with open('abc.txt','a') as file1:
    file1.write('张无忌') 
```
